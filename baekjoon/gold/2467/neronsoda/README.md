## 문제 출처
https://www.acmicpc.net/problem/2467
## 🔍 풀이
이 문제는 투 포인터를 사용하여 푼 문제이다.

투 포인터 풀이에는 `start` 변수와 `end` 변수가 사용된다.

투 포인터 문제 유형 중 `start`는 맨 첫 인덱스에서 오른쪽으로, `end`는 맨 마지막 인덱스에서 왼쪽으로 이동하는 유형으로 접근하면 된다.

이분 탐색과 동일하게, 투 포인터 또한 `start` 또는 `end`를 이동시키기 위한 조건이 필요하다.

이 조건은 `현재 start와 end를 이용한 어떤 값`과 `비교 기준이 되는 값`을 비교하는 것이다.

문제를 통해 위 두 값을 잘 지정해주어야 하는데, 이 문제에서는 `arr[start] + arr[end]`와 `0`을 비교해야 한다.

만약, `arr[start] + arr[end]` 값이 `0`보다 크다면 end를 감소시키고, 작거나 같다면 start를 증가시켜 범위를 좁혀나갈 수 있다.

각 `start`, `end` 조합마다 `arr[start] + arr[end]`의 절댓값을 구한 후, 기존의 최솟값과 비교하여 답이 될 두 값 `first`와 `second`를 갱신해준다.
## ✏️ 추가 지식
모든 문제에 적용될지는 모르겠으나, 이 문제는 두 가지 방식으로 풀 수 있다.

1. 투 포인터 O(N)
   - 내가 푼 방식
2. 이분탐색 O(NlogN)
   - for문을 통해 배열의 각 인덱스(i)를 돈다.
   - for문 내에서 이분 탐색을 통해 (i+1 ~ 마지막 인덱스) 범위를 탐색한다.
   - 탐색 과정에서 현재 인덱스(i)에 해당하는 arr[i]과의 합을 가장 0에 가깝게 만드는 경우를 찾아 갱신한다.
   - 
## 😊 후기
이 문제는 알고리즘 분류 중 이분탐색을 선택해서 나온 문제였기 때문에 너무 당연하게 풀이를 이분탐색으로만 한정해서 고민했다.

하지만, 계속 고민해봐도 이분탐색을 이용한 풀이가 그려지지 않았다.

오히려, 투포인터를 사용하면 금방 풀 수 있을 것 같다는 생각이 들었고 투포인터로 문제를 푸니까 금방 풀 수 있었다.

너무 알고리즘 분류에 얽매이지 않고 유연하게 풀어야겠다는 생각을 하게 되었다.